# 线程池 & 数据库连接池
## RAII机制
RAII的核心思想是将资源的生命周期绑定到对象的生命周期上。这意味着，当对象被创建时，资源会被获取（例如，分配内存、打开文件、获取锁等），当对象的生命周期结束时（例如，对象离开作用域、被显式删除等），资源会被自动释放（例如，释放内存、关闭文件、释放锁等）。
**RAII的实现方式**
- 构造函数和析构函数
```
class ResourceHandle {
private:
    Resource* resource;

public:
    ResourceHandle() : resource(acquireResource()) {
        // 资源获取在构造函数中完成
    }
    ~ResourceHandle() {
        releaseResource(resource);
        // 资源释放在析构函数中自动完成
    }
    // 其他成员函数...
};
```
- 作用域和生命周期
```
void someFunction() {
    ResourceHandle handle; // 资源在此处被获取
    // ... 使用资源
    // 当handle的作用域结束时，资源会自动被释放
}
```
- 智能指针
```
std::unique_ptr<Resource> resourcePtr(new Resource());
// 当resourcePtr的作用域结束时，它所管理的资源会被自动删除
```
在C++中，标准库广泛采用了RAII技术，例如std::lock_guard、std::unique_ptr、std::shared_ptr等。

## 线程池
使用线程池可以减少线程的销毁，而且如果不使用线程池的话，来一个客户端就创建一个线程。比如有1000，这样线程的创建、线程之间的调度也会耗费很多的系统资源，所以采用线程池使程序的效率更高。 线程池就是项目启动的时候，就先把线程池准备好。
一般线程池的实现是通过生产者消费者模型来的：
![](https://img-blog.csdnimg.cn/77a4124181da4fd69d200c1b532e57aa.png)

+ **线程同步问题**
线程同步问题涉及到了互斥量、条件变量。
在代码中，将互斥锁、条件变量、关闭状态、工作队列封装到了一起，通过一个共享智能指针来管理这些条件。

## 数据库连接池
[数据库连接池简介](https://blog.csdn.net/CrankZ/article/details/82874158)
我见过的连接池有用std::list写的，也有用std::queue写的，我个人还是比较倾向于用queue写。 
+ 为什么要使用连接池？
    - 由于服务器需要频繁地访问数据库，即需要频繁创建和断开数据库连接，该过程是一个很耗时的操作，也会对数据库造成安全隐患。
    - 在程序初始化的时候，集中创建并管理多个数据库连接，可以保证较快的数据库读写速度，更加安全可靠。

在连接池的实现中，使用到了信号量来管理资源的数量；而锁的使用则是为了在访问公共资源的时候使用。所以说，无论是条件变量还是信号量，都需要锁。

不同的是，信号量的使用要先使用信号量sem_wait再上锁，而条件变量的使用要先上锁再使用条件变量wait。